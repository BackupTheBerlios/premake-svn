//-----------------------------------------------------------------------------
// Premake - gnu.c
//
// GNU tool target.
//
// Copyright (C) 2002-2005 by Jason Perkins
// Source code licensed under the GPL, see LICENSE.txt for details.
//
// $Id: gnu.c,v 1.54 2005/09/30 21:17:29 jason379 Exp $
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <string.h>
#include "project.h"
#include "project_api.h"
#include "util.h"

#define MAKEFILE_EXT   ".make"
#define OBJECTS_EXT    ".o"

extern const char** commandLineArgs;
extern const char* rootProjectFile;
extern const char* cc;
extern const char* dotnet;
extern int verbose;

static int writeRootMakefile();
static int writeCppPackage(Package* package);
static int writeCsPackage(Package* package);

static char buffer[4096];

//-----------------------------------------------------------------------------

int makeGnuScripts()
{
	int i;

	puts("Generating GNU makefiles:");
	
	if (!writeRootMakefile())
		return 0;

	for (i = 0; i < project->numPackages; ++i)
	{
		int result;
		Package* package = project->package[i];
		const char* language = package->language;

		prj_select_package(i);

		printf("...%s\n", package->name);

		if (strcmp(language, "c#") == 0)
			result = writeCsPackage(package);
		else if (strcmp(language, "c++") == 0 || strcmp(language, "c") == 0)
			result = writeCppPackage(package);
		else
		{
			printf("** Error: unrecognized language '%s'\n", language);
			return 0;
		}

		if (!result) return 0;
	}

	return 1;
}

//-----------------------------------------------------------------------------

static int packageOwnsPath(Package* package)
{
	int i;
	if (strcmp(project->path, package->path) == 0)
		return 0;
	for (i = 0; i < project->numPackages; ++i)
	{
		if (project->package[i] != package &&
			  strcmp(project->package[i]->path, package->path) == 0)
			return 0;
	}
	return 1;
}

static const char* checkDeps(const char* ref, void* data)
{
	int i;
	for (i = 0; i < project->numPackages; ++i)
	{
		if (strcmp(project->package[i]->name, ref) == 0)
			return project->package[i]->name;
	}
	return NULL;
}

static int writeRootMakefile()
{
	int i;
	FILE* file;

	file = openFile(project->path, "Makefile", "");
	if (file == NULL)
	{
		puts("Error: unable to open Makefile\n");
		return 0;
	}

	// Print the header, showing the possible build configurations

	fprintf(file, "# Makefile autogenerated by premake\n");
	fprintf(file, "# Don't edit this file! Instead edit `premake.lua` then rerun `make`\n");
	fprintf(file, "# Options:\n");
	fprintf(file, "#   CONFIG=[");
	for (i = 0; i < project->package[0]->numConfigs; ++i)
	{
		if (i > 0) fprintf(file, "|");
		fprintf(file, project->package[0]->config[i]->name);
	}
	
	fprintf(file, "]\n\n");

	// Set a default build config if none specified
	
	fprintf(file, "ifndef CONFIG\n");
	fprintf(file, "  CONFIG=%s\n", project->package[0]->config[0]->name);
	fprintf(file, "endif\n\n");
	fprintf(file, "export CONFIG\n\n");
	
	// List all of the available make targets

	fprintf(file, ".PHONY: all clean");
	for (i = 0; i < project->numPackages; ++i)
		fprintf(file, " %s", project->package[i]->name);
	fprintf(file, "\n\n");

	// Make rules

	fprintf(file, "all:");
	for (i = 0; i < project->numPackages; ++i)
		fprintf(file, " %s", project->package[i]->name);
	fprintf(file, "\n\n");

	// Target to regenerate the makefiles when the premake scripts change

	fprintf(file, "Makefile: %s%s", reversePath(project->path, ".", UNIX, 1), rootProjectFile);
	for (i = 0; i < project->numPackages; ++i)
	{
		if (project->package[i]->script != NULL)
			fprintf(file, " %s%s", reversePath(project->path, ".", UNIX, 1), project->package[i]->script);
	}
	fprintf(file, "\n");
	fprintf(file, "\t@echo ==== Regenerating Makefiles ====\n");
	fprintf(file, "\t@premake");
	for (i = 1; args[i] != NULL; ++i)
		fprintf(file, " %s", args[i]);
	fprintf(file, "\n\n");

	/* Individual package targets */

	for (i = 0; i < project->numPackages; ++i)
	{
		Package* package = project->package[i];
		
		fprintf(file, "%s:", package->name);
			writeList(file, package->config[0]->links, " ", "", "", checkDeps, NULL);
			fprintf(file, "\n");

		fprintf(file, "\t@echo ==== Building %s ====\n", package->name);
		fprintf(file, "\t@$(MAKE) ");
		fprintf(file, "--no-print-directory -C %s", reversePath(project->path, package->path, UNIX, 1));
		if (!packageOwnsPath(package))
			fprintf(file, " -f %s%s", package->name, MAKEFILE_EXT);
		fprintf(file, "\n\n");
	}
	
	fprintf(file, "clean:\n");
	for (i = 0; i < project->numPackages; ++i)
	{
		Package* package = project->package[i];
		prj_select_package(i);

		fprintf(file, "\t@$(MAKE) ");
		fprintf(file, "--no-print-directory -C %s", reversePath(project->path, package->path, UNIX, 1));
		if (!packageOwnsPath(package))
			fprintf(file, " -f %s%s", package->name, MAKEFILE_EXT);
		fprintf(file, " clean\n");
	}
	
	fclose(file);
	return 1;
}

//-----------------------------------------------------------------------------

static const char* checkCppSources(const char* file, void* data)
{
	if (isCppFile(file))
		return replaceExtension(getFilename(file,0), OBJECTS_EXT);
	return NULL;
}

static void writeSourcePaths(FILE* file, const char* path, int stage)
{
	if (stage == WST_OPENGROUP && strlen(path) > 0)
		fprintf(file, " %s", path);
}

static const char* checkLink(const char* path, void* data)
{
	Package* package = getPackage(path);
	if (package == NULL) return path;

	if (strcmp(package->language, "c++") == 0 || strcmp(package->language, "c") == 0)
		return package->config[*((int*)data)]->target;
	
	return NULL;
}


/* This is called by the code that builds the list of dependencies for the
 * link step. It looks for sibling projects, and then returns the full
 * path to that target's output. So if an executable package depends on a
 * library package, the library filename will be listed as a dependency */

static const char* checkLinkDeps(const char* path, void* data)
{
	Package* package = getPackage(path);
	if (package != NULL)
	{
		strcpy(buffer, prj_get_outdir_for(package, UNIX, 1));
		strcat(buffer, prj_get_target_for(package));
		return buffer;
	}
	return NULL;
}

static const char* writeCppTargets(const char* file, void* data)
{
	if (isCppFile(file))
	{
		const char* ext = getExtension(file);

		sprintf(buffer, "$(OBJDIR)/%s: %s\n", replaceExtension(getFilename(file,0),".o"), file);
		strcat(buffer, "\t-@if [ ! -d $(OBJDIR) ]; then mkdir -p $(OBJDIR); fi\n");

		if (!verbose)
			strcat(buffer, "\t@echo $(notdir $<)\n");
      
		strcat(buffer, "\t");
		strcat(buffer, (verbose) ? "" : "@");

		if (cc != NULL && strcmp(cc, "dmc") == 0)
		{
			/* Digital Mars compiler build step */
			/* FIXME: How to handle assembly files with DMC? */
			if (strcmp(ext, ".c") == 0)
				strcat(buffer, "dmc $(CFLAGS) -o $@ -c $<\n");
			else if (strcmp(ext, ".s") != 0)
				strcat(buffer, "dmc -cpp -Ae -Ar -mn $(CXXFLAGS) -o $@ -c $<\n");
		}
		else
		{
			/* GNU GCC compiler build step */
			if (strcmp(ext, ".s") == 0)
				strcat(buffer, "$(CC) -x assembler-with-cpp $(CPPFLAGS) -o $@ -c $<\n");
			else if (strcmp(ext, ".c") == 0)
				strcat(buffer, "$(CC) $(CFLAGS) -o $@ -c $<\n");
			else
				strcat(buffer, "$(CXX) $(CXXFLAGS) -o $@ -c $<\n");
		}

		return buffer;
	}
	else
		return NULL;
}

static int writeCppPackage(Package* package)
{
	const char* prefix = (verbose>1) ? "" : "@";
	const char* comprefix = (verbose) ? "" : "@";

	FILE* file;
	int i;

	const char* name = package->name;
	const char* path = package->path;
	const char* kind = package->kind;

	/* Open package makefile and write the header */

	if (packageOwnsPath(package))
		file = openFile(package->path, "Makefile", "");
	else
		file = openFile(package->path, package->name, MAKEFILE_EXT);
	if (file == NULL) return 0;

	fprintf(file, "# ");
	if (strcmp(package->language, "c++") == 0)
		fprintf(file, "C++");
	else
		fprintf(file, "C");

	fprintf(file, " ");
	if (strcmp(package->kind, "exe") == 0)
		fprintf(file, "Console Executable");
	else if (strcmp(package->kind, "winexe") == 0)
		fprintf(file, "Windowed Executable");
	else if (strcmp(package->kind, "dll") == 0)
		fprintf(file, "Shared Library");
	else if (strcmp(package->kind, "lib") == 0)
		fprintf(file, "Static Library");

	fprintf(file, " Makefile autogenerated by premake\n");
	fprintf(file, "# Don't edit this file! Instead edit `premake.lua` then rerun `make`\n\n");

	/* Set a default configuration */

	fprintf(file, "ifndef CONFIG\n");
	fprintf(file, "  CONFIG=%s\n", package->config[0]->name);
	fprintf(file, "endif\n\n");

	/* Process the build configurations */
	for (i = 0; i < package->numConfigs; ++i)
	{
		const char* location;
		char  cflags[1024]   = { 0 };
		char  cxxflags[1024] = { 0 };
		char  ldflags[1024]  = { 0 } ;

		ProjectConfig* prjCfg = project->config[i];
		Config* config = package->config[i];

		prj_select_config(i);

		/* Compile the lists of flags */
		if (inArray(config->buildFlags, "no-exceptions"))
			strcat(cxxflags, " --no-exceptions");

		if (inArray(config->buildFlags, "no-frame-pointer"))
			strcat(cflags, "-fomit-frame-pointer");

		if (inArray(config->buildFlags, "no-rtti"))
			strcat(cxxflags, " --no-rtti");

		if (inArray(config->buildFlags, "no-symbols"))
			strcat(ldflags, " -s");
		else
			strcat(cflags, " -g");

		if (inArray(config->buildFlags, "optimize-size"))
			strcat(cflags, " -Os");

		if (inArray(config->buildFlags, "optimize-speed"))
			strcat(cflags, " -O3");

		if (inArray(config->buildFlags, "optimize") && !inArray(config->buildFlags, "optimize-size") && !inArray(config->buildFlags, "optimize-speed"))
			strcat(cflags, " -O2");

		if (inArray(config->buildFlags, "extra-warnings"))
			strcat(cflags, " -Wall");

		if (inArray(config->buildFlags, "fatal-warnings"))
			strcat(cflags, " -Werror");

		/* Set up the flags specific to the type of binary being built */
		location = "$(BINDIR)";
		if (strcmp(kind, "exe") == 0 || strcmp(kind, "winexe") == 0)
		{
			/* defaults are fine */
		}
		else if (strcmp(kind, "dll") == 0)
		{
			if (strcmp(os, "windows") != 0)
				strcat(cflags, " -fPIC");
			if (cc == NULL || strcmp(cc, "gcc") == 0)
				strcat(ldflags, " -shared");
		}
		else if (strcmp(kind, "lib") == 0)
		{
			location = "$(LIBDIR)";
		}
		else
		{
			printf("** Error: unknown package type '%s'\n", kind);
			return 0;
		}

		fprintf(file, "ifeq ($(CONFIG),%s)\n", config->name);

		fprintf(file, "  BINDIR = %s\n", prj_get_bindir(UNIX, 0));
		fprintf(file, "  LIBDIR = %s\n", prj_get_libdir(UNIX, 0));
		fprintf(file, "  OBJDIR = %s\n", prj_get_objdir(UNIX, 0));
		fprintf(file, "  OUTDIR = %s\n", prj_get_outdir(UNIX, 0));

		/* TODO: how to generate dependencies with DMC? */
		fprintf(file, "  CPPFLAGS =");
		if (cc == NULL || strcmp(cc, "dmc") != 0)
			fprintf(file, " -MD");
		writeList(file, config->defines, " -D \"", "\"", "", NULL, NULL);
		writeList(file, config->includePaths, " -I \"", "\"", "", NULL, NULL);
		fprintf(file, "\n");

		fprintf(file, "  CFLAGS += $(CPPFLAGS)%s", cflags);
		writeList(file, config->buildOptions, " ", "", "", NULL, "C");
		fprintf(file, "\n");

		fprintf(file, "  CXXFLAGS = $(CFLAGS)%s\n", cxxflags);

		fprintf(file, "  LDFLAGS += -L$(BINDIR) -L$(LIBDIR)%s", ldflags);
		if (matches(os, "macosx") && inArray(config->buildFlags, "dylib"))
			fprintf(file, " -dynamiclib -flat_namespace");
		writeList(file, config->linkOptions, " ", "", "", NULL, NULL);
		writeList(file, config->libPaths, " -L \"", "\"", "", NULL, NULL);
		writeList(file, config->links, " -l", "", "", checkLink, &i);
		fprintf(file, "\n");

		fprintf(file, "  LDDEPS =");
		writeList(file, config->links, " ", "", " ", checkLinkDeps, NULL);
		fprintf(file, "\n");

		fprintf(file, "  TARGET = %s\n", prj_get_target());
		
		if (matches(os, "macosx") && matches(kind, "winexe"))
			fprintf(file, "  MACAPP = %s\n", getFilename(config->target, 0));

		fprintf(file, "endif\n\n");
	}

	/* Write out the list of object file targets for all C/C++ sources */
	fprintf(file, "OBJECTS = \\\n");
	writeList(file, package->files, "\t$(OBJDIR)/", " \\\n", "", checkCppSources, NULL);
	fprintf(file, "\n");

	fprintf(file, ".PHONY: clean\n");
	fprintf(file, "\n");

	/* Write the main build target */
	if (matches(os, "macosx") && matches(kind, "winexe"))
	{
		fprintf(file, "all: $(BINDIR)/$(MACAPP).app/Contents/PkgInfo $(BINDIR)/$(MACAPP).app/Contents/Info.plist $(BINDIR)/$(TARGET)\n\n");
	}

	fprintf(file, "$(OUTDIR)/$(TARGET): $(OBJECTS) $(LDDEPS)\n");
	if(!verbose)
		fprintf(file, "\t@echo Linking %s\n", package->name);
	fprintf(file, "\t-%sif [ ! -d $(BINDIR) ]; then mkdir -p $(BINDIR); fi\n", prefix);
	fprintf(file, "\t-%sif [ ! -d $(LIBDIR) ]; then mkdir -p $(LIBDIR); fi\n", prefix);
	if (matches(os, "macosx") && matches(kind, "winexe"))
		fprintf(file, "\t-%sif [ ! -d $(BINDIR)/$(MACAPP).app/Contents/MacOS ]; then mkdir -p $(BINDIR)/$(MACAPP).app/Contents/MacOS; fi\n", prefix);

	if (strcmp(kind, "lib") == 0)
	{
		fprintf(file, "\t%sar -cr $@ $^\n", comprefix);
		fprintf(file, "\t%sranlib $@\n", comprefix);
	}
	else
	{
		fprintf(file, "\t%s$(CXX) -o $@ $(OBJECTS) $(LDFLAGS)\n", comprefix);
	}
	fprintf(file, "\n");

	if (matches(os, "macosx") && matches(kind, "winexe"))
	{
		fprintf(file, "$(BINDIR)/$(MACAPP).app/Contents/PkgInfo:\n");
		fprintf(file, "\n");

		fprintf(file, "$(BINDIR)/$(MACAPP).app/Contents/Info.plist:\n");
		fprintf(file, "\n");
	}

	/* Write the "clean" target */
	fprintf(file, "clean:\n");
	fprintf(file, "\t@echo Cleaning %s\n", package->name);
	if (matches(os, "macosx") && matches(kind, "winexe"))
	{
		fprintf(file, "\t-%srm -rf $(OUTDIR)/$(MACAPP).app $(OBJDIR)/*\n", comprefix);
	}
	else
	{
		fprintf(file, "\t-%srm -rf $(OUTDIR)/$(TARGET) $(OBJDIR)/*\n", comprefix);
	}
	fprintf(file, "\n");

	/* Write static patterns for each source file. Note that in earlier
	 * versions I used pattern rules instead of listing each file. It worked
	 * fine but made it more difficult to test and also required the use of
	 * VPATH which I didn't like. This new approach of listing each file
	 * helps testing and opens the way for per-file configurations */
	writeList(file, package->files, "", "\n", "", writeCppTargets, NULL);

	/* Include the automatically generated dependency lists */
	fprintf(file, "-include $(OBJECTS:%%.o=%%.d)\n\n");

	fclose(file);
	return 1;
}

//-----------------------------------------------------------------------------

static const char* checkReferences(const char* file, void* data)
{
	Package* package = getPackage(file);
	if (package == NULL) return file;
	if (strcmp(package->language, "c#") != 0) return NULL;
	return package->config[*((int*)data)]->target;
}


/* This is called by the code that builds the list of dependencies for the
 * link step. It looks for sibling projects, and then returns the full
 * path to that target's output. So if an executable package depends on a
 * library package, the library filename will be listed as a dependency */

static const char* checkReferenceDeps(const char* path, void* data)
{
	Package* package = getPackage(path);
	if (package != NULL)
	{
		strcpy(buffer, prj_get_outdir_for(package, UNIX, 1));
		strcat(buffer, prj_get_target_for(package));
		return buffer;
	}
	return NULL;
}


typedef struct BuildActionData
{
	Package* package;
	const char* buildAction;
	const char* fileExtension;
} BuildActionData;

/* Checks to see if a particular file fits a desired build action */
int csMatchFile(const char* fileName, BuildActionData* data)
{
	FileConfig* config = getFileConfig(data->package, fileName);

	if (NULL != config->buildAction)
		return (0 == strcmp(config->buildAction, data->buildAction));

	if (NULL != data->fileExtension && 0 == strcmp(getExtension(fileName), data->fileExtension))
	{
		config->buildAction = data->buildAction;
		return 1;
	}

	if (NULL == data->fileExtension)
	{
		config->buildAction = data->buildAction;
		return 1;
	}

	return 0;
}

/* Visual Studio .NET automatically adds some extra information
 * to resource names. Simulate that here */
static const char* makeVsNetCompatName(const char* file, Package* pkg)
{
	if (matches(getExtension(file), ".resx"))
	{
		char* ptr;

		/* All compiled resources go into the obj dir */
		strcpy(buffer, pkg->objdir);
		strcat(buffer, "/");

		/* Prepend the default namespace */
		strcat(buffer, pkg->config[0]->target);
		strcat(buffer, ".");

		/* Followed by the path to the resource file */
		if (!matches("./", getDirectory(file, 1)))
			strcat(buffer, getDirectory(file, 1));

		/* Followed by the resourcename.resources */
		strcat(buffer, getFilename(file, 1));
		strcat(buffer, ".resources");

		/* Convert any slashes to dots */
		for (ptr = buffer + strlen(pkg->objdir) + 1; *ptr != '\0'; ++ptr)
		{
			if (*ptr == '/')
				*ptr = '.';
		}

		return buffer;
	}
	else
	{
		return file;
	}
}

/* Filters the list of files against a desired build action */
static const char* csBuildActionFilter(const char* file, void* data)
{
	BuildActionData* bad = (BuildActionData*)data;
	if(csMatchFile(file, bad))
		return makeVsNetCompatName(file, bad->package);
	return NULL;
}

/* Writes out resource compilation steps */
static const char* csResourceBuildStep(const char* file, void* data)
{
	if (matches(".resx", getExtension(file)))
	{
		makeVsNetCompatName(file, (Package*)data);
		strcat(buffer, ": ");
		strcat(buffer, file);
		strcat(buffer, "\n\t-@if [ ! -d $(OBJDIR) ]; then mkdir -p $(OBJDIR); fi");
		strcat(buffer, "\n\t$(RESGEN) $^ $@\n\n");
		return buffer;
	}
	else
	{
		return NULL;
	}
}


/* Add all content files as dependencies to the `all:` target. This will
 * cause the rules written by csContentRulesList() to fire */
static const char* csContentTargetsList(const char* file, void* data)
{
	BuildActionData* bad = (BuildActionData*)data;
	if (csMatchFile(file, bad))
	{
		sprintf(buffer, "$(BINDIR)/%s", getFilename(file,0));
		return buffer;
	}
	return NULL;
}

/* Write copy rules for all content files to move them to the output directory */
static const char* csContentRuleList(const char* file, void* data)
{
	BuildActionData* bad = (BuildActionData*)data;
	if (csMatchFile(file, bad))
	{
		sprintf(buffer, "$(BINDIR)/%s: %s\n\t-@cp -fR $^ $@\n\n", getFilename(file,0), file);
		return buffer;
	}
	return NULL;
}

static int writeCsPackage(Package* package)
{
	BuildActionData bad;
	const char* extension;
	const char* csc;
	const char* resgen;
	FILE* file;
	int i;

	// Figure out what I'm building

	const char* name = package->name;
	const char* path = package->path;
	const char* kind = package->kind;

	if (strcmp(kind, "dll") == 0 || strcmp(kind, "aspnet") == 0)
	{
		extension = ".dll";
		kind = "library";
	}
	else if (strcmp(kind, "winexe") == 0 || strcmp(kind, "exe") == 0)
	{
		extension = ".exe";
	}
	else
	{
		printf("** Error: unknown package type '%s'\n", kind);
		return 0;
	}

	/* Figure out what I'm building it with */

	if (dotnet == NULL)
	{
		if (strcmp(os, "windows") == 0)
		{
			csc = "csc";
			resgen = "resgen";
		}
		else
		{
			csc = "mcs";
			resgen = "monoresgen";
		}
	}
	else if (strcmp(dotnet, "ms") == 0)
	{
		csc = "csc";
		resgen = "resgen";
	}
	else if (strcmp(dotnet, "pnet") == 0)
	{
		csc = "cscc";
		resgen = "resgen";
	}
	else if (strcmp(dotnet, "mono") == 0)
	{
		csc = "mcs";
		resgen = "monoresgen";
	}
	else
	{
		printf("** Error: unknown .NET runtime '%s'\n", dotnet);
		return 0;
	}

	/* Open package makefile and write the header */

	if (packageOwnsPath(package))
		file = openFile(package->path, "Makefile", "");
	else
		file = openFile(package->path, package->name, MAKEFILE_EXT);
	if (file == NULL) return 0;

	fprintf(file, "# C# ");
	if (strcmp(package->kind, "exe") == 0)
		fprintf(file, "Console Executable");
	else if (strcmp(package->kind, "winexe") == 0)
		fprintf(file, "Windowed Executable");
	else if (strcmp(package->kind, "dll") == 0)
		fprintf(file, "Shared Library");
	else if (strcmp(package->kind, "lib") == 0)
		fprintf(file, "Static Library");
	else if (strcmp(package->kind, "aspnet") == 0)
		fprintf(file, "ASP.NET");

	fprintf(file, " Makefile autogenerated by premake\n");
	fprintf(file, "# Don't edit this file! Instead edit `premake.lua` then rerun `make`\n\n");

	/* Set a default configuration */
	fprintf(file, "ifndef CONFIG\n");
	fprintf(file, "  CONFIG=%s\n", package->config[0]->name);
	fprintf(file, "endif\n\n");

	/* Specify the build tools */
	fprintf(file, "CSC = %s\n", csc);
	fprintf(file, "RESGEN = %s\n", resgen);
	fprintf(file, "\n");

	/* Where to put compiled resources */
	fprintf(file, "OBJDIR = %s\n\n", package->objdir);

	/* Process the build configurations */
	for (i = 0; i < package->numConfigs; ++i)
	{
		ProjectConfig* prjCfg = project->config[i];
		Config* config = package->config[i];

		int symbols   = !inArray(config->buildFlags,"no-symbols");
		int optimize  =  inArray(config->buildFlags,"optimize")||inArray(config->buildFlags,"optimize-size")||inArray(config->buildFlags,"optimize-speed");
		int unsafe    =  inArray(config->buildFlags,"unsafe");
		int fatalWarn =  inArray(config->buildFlags, "fatal-warnings");

		prj_select_config(i);

		fprintf(file, "ifeq ($(CONFIG),%s)\n", config->name);

		fprintf(file, "  BINDIR = %s\n", prj_get_bindir(UNIX, 1));
		fprintf(file, "  OUTDIR = ");
			fprintf(file, prj_get_bindir(UNIX, 1));
			insertPath(file, getDirectory(package->config[0]->target, 0), UNIX, 0);
			fprintf(file, "\n");
	
		fprintf(file, "  FLAGS +=");
		if (symbols)   fprintf(file, " /debug");
		if (optimize && !matches(csc,"mcs"))  fprintf(file, " /o");
		if (unsafe)    fprintf(file, " /unsafe");
		if (fatalWarn) fprintf(file, " /warnaserror");
		writeList(file, config->defines, " /d:", "", "", NULL, NULL);
		/* VS.NET doesn't allow per-config lib paths */
		writeList(file, package->config[0]->libPaths, " /lib:\"", "\"", "", NULL, NULL);
		/* VS.NET doesn't allow per-config links */
		writeList(file, package->config[0]->links, " /r:", ".dll", "", checkReferences, &i);
		fprintf(file, "\n");

		/* List any package dependencies so that this assembly will rebuild
		 * if any of them are modified */
		fprintf(file, "  DEPS =");
		writeList(file, config->links, " ", "", " ", checkReferenceDeps, NULL);
		fprintf(file, "\n");

		/* Use the same targets for all configs in order to maintain
		 * compatibility with VS.NET */
		fprintf(file, "  TARGET = %s%s\n", getFilename(package->config[0]->target, 0), extension);
		fprintf(file, "endif\n\n");
	}
	
	/* Sort out the files by build action */
	fprintf(file, "SOURCES = \\\n");
	bad.package = package;
	bad.fileExtension = ".cs";
	bad.buildAction = "Code";
	writeList(file, package->files, "\t", " \\\n", "", csBuildActionFilter, &bad);
	fprintf(file, "\n");

	bad.fileExtension = ".resx";
	bad.buildAction = "EmbeddedResource";
	fprintf(file, "EMBEDDEDFILES = \\\n");
	writeList(file, package->files, "\t", " \\\n", "", csBuildActionFilter, &bad);
	fprintf(file, "\n");

	fprintf(file, "EMBEDDEDCOMMAND = \\\n");
	writeList(file, package->files, "\t/resource:", " \\\n", "", csBuildActionFilter, &bad);
	fprintf(file, "\n");

	bad.fileExtension = NULL;
	bad.buildAction = "LinkedResource";
	fprintf(file, "LINKEDFILES = \\\n");
	writeList(file, package->files, "\t", " \\\n", "", csBuildActionFilter, &bad);
	fprintf(file, "\n");

	fprintf(file, "LINKEDCOMMAND = \\\n");
	writeList(file, package->files, "\t/linkresource:", " \\\n", "", csBuildActionFilter, &bad);
	fprintf(file, "\n");

	fprintf(file, "COMPILECOMMAND = $(SOURCES) $(EMBEDDEDCOMMAND) $(LINKEDCOMMAND)\n");
	fprintf(file, "\n");

	/* Build targets: add all content files as dependencies so the copy
	 * rules will get fired when they change */
	fprintf(file, ".PHONY: clean\n\n");

	fprintf(file, "all: \\\n");
	fprintf(file, "\t$(OUTDIR)/$(TARGET) \\\n");

	bad.fileExtension = NULL;
	bad.buildAction = "LinkedResource";
	writeList(file, package->files, "\t", " \\\n", "", csContentTargetsList, &bad);
	bad.buildAction = "Content";
	writeList(file, package->files, "\t", " \\\n", "", csContentTargetsList, &bad);
	fprintf(file, "\n");

	/* The main build target */
	fprintf(file, "$(OUTDIR)/$(TARGET): $(SOURCES) $(EMBEDDEDFILES) $(LINKEDFILES) $(DEPS)\n");
	fprintf(file, "\t-@if [ ! -d $(OUTDIR) ]; then mkdir -p $(OUTDIR); fi\n");
	fprintf(file, "\t@$(CSC) /nologo /out:$@ /t:%s /lib:$(BINDIR) $(FLAGS) $(COMPILECOMMAND)\n\n", kind);

	/* The content files copy targets */
	bad.buildAction = "LinkedResource";
	writeList(file, package->files, "", "", "", csContentRuleList, &bad);
	bad.buildAction = "Content";
	writeList(file, package->files, "", "", "", csContentRuleList, &bad);

	/* The clean target */
	fprintf(file, "clean:\n");
	fprintf(file, "\t@echo Cleaning %s\n", name);
	fprintf(file, "\t-@rm -f $(OUTDIR)/$(TARGET)\n");
	fprintf(file, "\t-@rm -fR $(OBJDIR)\n");
	bad.buildAction = "LinkedResource";
	writeList(file, package->files, "\t-@rm -f ", "\n", "", csContentTargetsList, &bad);
	bad.buildAction = "Content";
	writeList(file, package->files, "\t-@rm -f ", "\n", "", csContentTargetsList, &bad);
	fprintf(file, "\n");

	/* Resource build targets */
	writeList(file, package->files, "", "", "", csResourceBuildStep, package);

	fclose(file);
	return 1;
}
