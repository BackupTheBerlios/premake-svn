/**********************************************************************
 * Premake - gnu.c
 * The GNU makefile target
 *
 * Copyright (c) 2002-2005 Jason Perkins.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License in the file LICENSE.txt for details.
 **********************************************************************/

#include <stdio.h>
#include "premake.h"
#include "gnu.h"

static int writeRootMakefile();


int makeGnuTarget()
{
	puts("Generating GNU makefiles:");

	if (!writeRootMakefile())
		return 0;

	return 1;
}



static int writeRootMakefile()
{
	if (!io_openfile(path_join(prj_getpath(), "Makefile", "")))
		return 0;

#if 0
	int i;
	FILE* file;

	file = io_openfile(path_join(project->path, "Makefile", ""));
	if (file == 

		
		openFile(project->path, "Makefile", "");
	if (file == NULL)
	{
		puts("Error: unable to open Makefile\n");
		return 0;
	}

	// Print the header, showing the possible build configurations

	fprintf(file, "# Makefile autogenerated by premake\n");
	fprintf(file, "# Don't edit this file! Instead edit `premake.lua` then rerun `make`\n");
	fprintf(file, "# Options:\n");
	fprintf(file, "#   CONFIG=[");
	for (i = 0; i < project->package[0]->numConfigs; ++i)
	{
		if (i > 0) fprintf(file, "|");
		fprintf(file, project->package[0]->config[i]->name);
	}
	
	fprintf(file, "]\n\n");

	// Set a default build config if none specified
	
	fprintf(file, "ifndef CONFIG\n");
	fprintf(file, "  CONFIG=%s\n", project->package[0]->config[0]->name);
	fprintf(file, "endif\n\n");
	fprintf(file, "export CONFIG\n\n");
	
	// List all of the available make targets

	fprintf(file, ".PHONY: all clean");
	for (i = 0; i < project->numPackages; ++i)
		fprintf(file, " %s", project->package[i]->name);
	fprintf(file, "\n\n");

	// Make rules

	fprintf(file, "all:");
	for (i = 0; i < project->numPackages; ++i)
		fprintf(file, " %s", project->package[i]->name);
	fprintf(file, "\n\n");

	// Target to regenerate the makefiles when the premake scripts change

	fprintf(file, "Makefile: %s%s", reversePath(project->path, ".", UNIX, 1), rootProjectFile);
	for (i = 0; i < project->numPackages; ++i)
	{
		if (project->package[i]->script != NULL)
			fprintf(file, " %s%s", reversePath(project->path, ".", UNIX, 1), project->package[i]->script);
	}
	fprintf(file, "\n");
	fprintf(file, "\t@echo ==== Regenerating Makefiles ====\n");
	fprintf(file, "\t@premake");
	for (i = 1; args[i] != NULL; ++i)
		fprintf(file, " %s", args[i]);
	fprintf(file, "\n\n");

	/* Individual package targets */

	for (i = 0; i < project->numPackages; ++i)
	{
		Package* package = project->package[i];
		
		fprintf(file, "%s:", package->name);
			writeList(file, package->config[0]->links, " ", "", "", checkDeps, NULL);
			fprintf(file, "\n");

		fprintf(file, "\t@echo ==== Building %s ====\n", package->name);
		fprintf(file, "\t@$(MAKE) ");
		fprintf(file, "--no-print-directory -C %s", reversePath(project->path, package->path, UNIX, 1));
		if (!packageOwnsPath(package))
			fprintf(file, " -f %s%s", package->name, MAKEFILE_EXT);
		fprintf(file, "\n\n");
	}
	
	fprintf(file, "clean:\n");
	for (i = 0; i < project->numPackages; ++i)
	{
		Package* package = project->package[i];
		prj_select_package(i);

		fprintf(file, "\t@$(MAKE) ");
		fprintf(file, "--no-print-directory -C %s", reversePath(project->path, package->path, UNIX, 1));
		if (!packageOwnsPath(package))
			fprintf(file, " -f %s%s", package->name, MAKEFILE_EXT);
		fprintf(file, " clean\n");
	}
#endif
	
	io_closefile();
	return 1;
}
